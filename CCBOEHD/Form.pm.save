#!/usr/bin/perl

package CCBOEHD::Form;
use base qw(CCBOEHD::Base);

use strict;
use warnings;

use CGI::Carp qw(fatalsToBrowser);

use DBI;
use CGI;
use YAML;

##
## Overrides
##

sub setup
{
	my $self = shift;

	$self->start_mode('new');
	$self->mode_param('mode');
	$self->run_modes(
		'new' => 'new_mode',
		'create' => 'create_mode',
		'edit' => 'edit_mode',
		'update' => 'update_mode',
	);
	$self->load_config;
	$self->db_connect;
}

## 
## Interface functions
## 

sub new_mode{
	my $self = shift;
	my %form = $self->form_to_variables();
	$self->load_template($self->param('config')->{'template_dir'}.'/'.$self->param('config')->{'pnd'}->{$form{'app'}}->{'ticket.pl'}->{'new'}->{'template'});

	my $form = YAML::LoadFile($self->param('config')->{'config_dir'}.'/'.$self->param('config')->{'pnd'}->{$form{'app'}}->{'ticket.pl'}->{'new'}->{'form'});

	$self->param('template')->param('self_url' => $self->query->url);

	$self->fill_loops_createmode($form);

	return $self->param('template')->output();
}

sub fill_loops_createmode{
	my $self = shift;
	my $form = shift;
	my %FORM = $self->form_to_variables();

	# Fill loop H::T vars
	my %loopsql = $self->get_loop_sqls($form);
	my @loop_objects = $self->get_loop_objects($form);
	foreach my $lobj (@loop_objects){
		# Special case (how I loathe thee!) to select the current school's IP
		if($lobj->{'value_from_db_field'} eq 'School'){
			$lobj->{'default_selected'} = $FORM{$lobj->{'value_from_html_field'}} || $self->school_from_ip() || $lobj->{'default_selected'};
		}
		# Form, SQL, Loopname, Match value
		$self->insert_loop_into_template($form,$loopsql{$lobj->{'loopname'}},$lobj->{'loopname'},$lobj->{'default_selected'});
	}
	return;
}

sub create_mode{
	my $self = shift;

	my $debug;

	my %form = $self->form_to_variables();
	my $form = YAML::LoadFile($self->param('config')->{'config_dir'}.'/'.$self->param('config')->{'pnd'}->{$form{'app'}}->{'ticket.pl'}->{'new'}->{'form'});
	my @err = $self->check_requirements($self->param('config')->{'config_dir'}.'/'.$self->param('config')->{'pnd'}->{$form{'app'}}->{'ticket.pl'}->{'create'}->{'requirements'},%form);

	if(@err){
		# create_error mode
		$self->load_template($self->param('config')->{'pnd'}->{$form{'app'}}->{'ticket.pl'}->{'create'}->{'error_template'});

		$self->param('template')->param('errors' => [@err]);

		$self->highlight_on_error(@err);

		$self->form_fill(%form);

		$self->fill_loops_createmode($form);
	} else{
		# Insert the new row, capture the primary key

		my $pkey = ($self->next_primarykey_value())+1;

		my %flds;
		$flds{'helpdesk'} = { 
			'requested' => $self->param('hddb')->selectrow_array("select from_unixtime(".(time).");"),
			'updated' => $self->param('hddb')->selectrow_array("select from_unixtime(".(time).");"),
			$self->param('select_html_field') => $pkey,
			'status' => $self->param('hddb')->selectrow_array("select min(tsid) from ticket_status;"),
		};

		my @statements =  $self->create_insert_statements2($self->param('config')->{'config_dir'}.'/'.$self->param('config')->{'pnd'}->{$form{'app'}}->{'ticket.pl'}->{'create'}->{'form'},\%form,%flds);

		my @error;
		foreach my $st (@statements){
			my $rc = $self->param('hddb')->do($st);
			if(!defined($rc)){
				my $e = $self->param('hddb')->errstr;
				push(@error,{'error' => $e});
			}
		}
		if(@error){
			$self->load_template($self->param('config')->{'config_dir'}.'/'.$$self->param('config')->{'pnd'}->{'helpdesk'}->{'ticket.pl'}->{'create'}->{'error_template'});
			$self->param('template')->param('sql_error',[@error]);
			$self->form_fill(%form);
			$self->fill_loops_createmode($form);
		} else{
			$self->load_template($self->param('config')->{'pnd'}->{$form{'app'}}->{'ticket.pl'}->{'create'}->{'template'});
#			my %nfm = $self->load_nfm($self->param('config')->{'config_dir'}.'/'.$self->param('config')->{'pnd'}->{'helpdesk'}->{'ticket.pl'}->{'create'}->{'nfm'});
#die Data::Dumper::Dumper $self->param('config')->{'pnd'};
#die $form{'app'};
#die 
#die 
#$self->param('config')->{'config_dir'}.'/'.$self->param('config')->{'pnd'}->{$form{'app'}}->{'ticket.pl'}->{'form'};
#die $self->param('config')->{'config_dir'}.'/'.$self->param('config')->{'pnd'}->{'helpdesk'}->{'ticket.pl'}->{'create'}->{'form'};
			$self->fill($pkey,$self->param('config')->{'config_dir'}.'/'.$self->param('config')->{'pnd'}->{'helpdesk'}->{'ticket.pl'}->{'create'}->{'form'});

#$self->fill($pkey,$self->param('config')->{'config_dir'}.'/'.$self->param('config')->{'pnd'}->{'helpdesk'}->{'ticket.pl'}->{'create'}->{'form'});

		}
	}

	$self->param('template')->param('debug' => $debug);

	return $self->param('template')->output();
}


sub edit_mode{
	my $self = shift;

	$self->load_template($self->param('config')->{'pnd'}->{'helpdesk'}->{'ticket.pl'}->{'edit'}->{'template'});

	# Let's test the cross-table inventory select!
	$self->param('template')->param('inventory_is_working_now' => 1);

	my %form = $self->form_to_variables();
	$self->param('template')->param('self_url' => $self->query->url);

	if(defined($form{$self->param('select_html_field'}})){
		$self->fill($self->param('select_html_field'},$self->param('config')->{'config_dir'}.'/'.$self->param('config')->{'pnd'}->{$form{'app'}}->{'ticket.pl'}->{'edit'}->{'form'});
	} else{
		# An error page would be appropriate
		die "Something wicked happened! $!!. This means you forgot to give me a primary key field.";
	}

	return $self->param('template')->output();
}

sub update_mode{
	my $self = shift;
	my %form = $self->form_to_variables();

	$self->load_template($self->param('config')->{'pnd'}->{$form{'app'}}->{'ticket.pl'}->{'update'}->{'template'});
	$self->param('template')->param('self_url' => $self->query->url);

	# An ugly hack! I see no clean way to avoid it at the moment
	my %flds;
	if($form{'app'} eq 'helpdesk'){
		$flds{'helpdesk'} = { 
			'updated' => $self->param('hddb')->selectrow_array("select from_unixtime(".(time).");"),
		};
	}

	my @updates = $self->create_update_statements($self->param('config')->{'config_dir'}.'/'.$self->param('config')->{'pnd'}->{$form{'app'}}->{'ticket.pl'}->{'update'}->{'form'},\%form,%flds);
#die $updates[0];
	# Catch the return code so we can check the status of what jsut happened.
	my (@rc,@err,$rowtot);
	foreach my $upd (@updates){
		my $rc = $self->param('hddb')->do($upd);
		if(!defined($rc)){
			my $e = $self->param('hddb')->errstr;;
			push(@err,{'error' => $e});
		} else{
			$rowtot += $rc;
		}
	}
#	$err[0] = {'error'=>'foo is bad!'}; # Force an error condition. Fot testing.
	if(@err){
		$self->param('template')->param('sql_error',[@err]);
	} elsif($rowtot){
		$self->param('template')->param('sql_success',$rowtot);
	}

#	$self->param('template')->param('debug' => $debug);

	$self->fill(,$self->param('config')->{'config_dir'}.'/'.$self->param('config')->{'pnd'}->{$form{'app'}}->{'ticket.pl'}->{'update'}->{'form'});

	return $self->param('template')->output();
}



## 
## Internal functions
## 

#
# New mode functions
#

#
# Create mode functions
#
sub create_insert_statements2{
	my $self = shift;
	my $formfile = shift;
	my $formsubmit = shift;
	my %special_inserts = @_;

	my %form = %{$formsubmit};
	my $form2 = YAML::LoadFile($formfile);

	my @inserts;
	foreach my $t (keys %{$form2->{'fields'}}){
		my $statement = 'insert into '.$t.' ';
		my (@fieldlist,@valuelist);
		foreach my $f (@{$form2->{'fields'}->{$t}}){
			if(defined $f->{'html_field'} && defined $f->{'db_field'}){
				push(@fieldlist,$f->{'db_field'});
				push(@valuelist,$form{$f->{'html_field'}});
			}
		}
		if($special_inserts{$t}){
			foreach my $f (keys %{$special_inserts{$t}}){
				push(@fieldlist,$f);
				push(@valuelist,$special_inserts{$t}->{$f});
			}
		}

		if(@fieldlist && @valuelist){
			$statement .= '('.join(', ',@fieldlist).') values ('.join(', ',(map {$self->param('hddb')->quote($_)} @valuelist)).');';
#			$statement .= '('.join(', ',@fieldlist).') values ('.join(', ',@valuelist).');';
			push(@inserts,$statement);
		}
	}
#die Data::Dumper::Dumper @inserts;
	return @inserts;
}

sub create_insert_statements{
	my $self = shift;
	my $smap = shift;

	my $ref = YAML::LoadFile($smap);
	my $form = shift;
	my %special_inserts = @_;
	my @inserts;
	my @tables = keys %{$ref};

	foreach my $t (@tables){
		my %fields;
		my $statement = 'insert into '.$t.' ';
		foreach my $k (keys %{$ref->{$t}}){
			if(defined($form->{$k})){
				$fields{$ref->{$t}->{$k}} = $form->{$k};
			}
		}
		my @fieldlist;
		my @valuelist;
		foreach my $f (keys %fields){
			push(@fieldlist,$f);
			push(@valuelist,$fields{$f});
		}

		if($special_inserts{$t}){
			foreach my $f (keys %{$special_inserts{$t}}){
				push(@fieldlist,$f);
				push(@valuelist,$special_inserts{$t}->{$f});
			}
		}

		$statement .= '('.join(',',@fieldlist).') values ('.join(',',(map {$self->param('hddb')->quote($_)} @valuelist)).');';
		push(@inserts,$statement);
	}

	return @inserts;
}


sub next_primarykey_value{
	my $self = shift;
	my %form = $self->form_to_variables;
	my $y = YAML::LoadFile($self->param('config')->{'pnd'}->{$form{'app'}}->{'ticket.pl'}->{'form'});
        foreach my $c (@{$y->{'primarytable'}}){
		if($c->{'table'} eq $y->{'primarytable'}){
			$self->param('select_db_field',$c->{'db_field'});
			$self->param('select_ht_field',$c->{'db_field'});
			$self->param('select_html_field',$c->{'html_field'});
			last;
		}
	}
	return $self->param('hddb')->selectrow_array("select max(".$self->param('select_db_field').") from ".$y->{'primarytable'}.;");
}

#
# Edit mode functions
#

#
# Update mode functions
#

sub create_update_statements{
	my $self = shift;
	my $formfile = shift;
	my $formsubmit = shift;
	my %special_updates = @_;

	my %form = %{$formsubmit};
#	my %form = $self->form_to_variables();
	my $form2 = YAML::LoadFile($formfile);

	my @updates;
#die Data::Dumper::Dumper %form;
	foreach my $t (keys %{$form2->{'fields'}}){
		my $statement = 'update '.$t.' set ';
		my @sets;
		foreach my $f (@{$form2->{'fields'}->{$t}}){
			if(defined $f->{'html_field'} && defined $f->{'db_field'}){
				push(@sets,$f->{'db_field'}.' = '.$self->param('hddb')->quote($form{$f->{'html_field'}}));
			}
		}
		if($special_updates{$t}){
			foreach my $f (keys %{$special_updates{$t}}){
				push(@sets,$f.' = '.$self->param('hddb')->quote($special_updates{$t}->{$f}));
			}
		}

		my $val = $self->param('hddb')->quote($form{$form2->{'where'}->{$t}->{'ht_field'}});
		my $pat = $self->operator_txt_to_pattern($form2->{'where'}->{$t}->{'comparison'});
		$pat =~ s/\*/$val/;
		my $where = 'where '.$form2->{'where'}->{$t}->{'db_field'}.' '.($self->operator_txt_to_operator($form2->{'where'}->{$t}->{'comparison'})).' '.$val;
		if(@sets){
			$statement .= join(', ', @sets).' '.$where.';';
			push(@updates,$statement);
		}
	}
#	die Data::Dumper::Dumper $form2->{'fields'}->{'helpdesk'};
#	die Data::Dumper::Dumper  @updates;
#
#	my $ref = YAML::LoadFile($self->param('config')->{'config_dir'}.'/'.$yaml_file);
#	my $form = shift;
#	my %special_updates = @_;
#	my @tables = keys %{$ref};
#
#	foreach my $t (@tables){
#		my %fields;
#		my $statement = 'update '.$t.' set ';
#		my @sets;
#		foreach my $k (keys %{$ref->{$t}->{'map'}}){
#			if(defined($form->{$k})){
#				push(@sets,$ref->{$t}->{'map'}->{$k}.' = '.$self->param('hddb')->quote($form->{$k}));
#			}
#		}
#		if($special_updates{$t}){
#			foreach my $f (keys %{$special_updates{$t}}){
#				$form->{$f} = $special_updates{$t}->{$f};
#				push(@sets,$f.' = '.$self->param('hddb')->quote($special_updates{$t}->{$f}));
#			}
#		}
#
#		# Change the 'where = %s' into where = ACTUAL_TICKET_NUMBER
#		$ref->{$t}->{'where'} = sprintf($ref->{$t}->{'where'},$self->param('hddb')->quote($form->{$ref->{$t}->{'field'}}));
#
#		$statement .= join(', ',@sets).' where '.$ref->{$t}->{'where'}.';';
##		my $m = grep { /\%/g } $statement;
##die $statement;
##		$statement = sprintf($statement,$self->param('hddb')->quote($form->{$ref->{$t}->{'field'}}));
##die $form->{$ref->{$t}->{'field'}};
##die $statement;
#		push(@updates,$statement);
#	}
#die Data::Dumper::Dumper @updates;
	return @updates;
}

#
# Common or generic functions
#

sub fill{
	my $self = shift;
	my $match = shift;
	my $file = shift;
	my $form = YAML::LoadFile($file);
#$self->param('config')->{'config_dir'}.'/'.$self->param('config')->{'pnd'}->{'helpdesk'}->{'ticket.pl'}->{$mode}->{'form'});

	my $fieldsobj = $form->{'fields'};

	my $sql = $self->form_to_sql($match,$form);
	my %loopsql = $self->get_loop_sqls($form);

	my @labels_and_names = $self->get_template_name_to_label_mapping($form);
	my @loop_objects = $self->get_loop_objects($form);
#die Data::Dumper::Dumper $form;;
#die $sql;
	my $result = $self->param('hddb')->selectrow_hashref($sql);

	foreach my $label (keys %{$result}){
		# Fill regular H::T vars
		foreach my $mapping (@labels_and_names){
			if($mapping->{'label'} eq $label){
				$self->param('template')->param($mapping->{'name'},$result->{$label});
				last;
			}
		}
		# Fill loop H::T vars
		foreach my $lobj (@loop_objects){
			if($lobj->{'value_from_db_field'} eq $label){
				# Form, SQL, Loopname, Match value
				$self->insert_loop_into_template($form,$loopsql{$lobj->{'loopname'}},$lobj->{'loopname'},$result->{$label});
				last;
			}
		}
	}

	return;
}

sub get_loop_objects{
	my $self = shift;
	my $form = shift;
	my @loops;
	foreach my $k (keys %{$form->{'lists'}}){
		$form->{'lists'}->{$k}->{'loopname'} = $k;
		push(@loops,$form->{'lists'}->{$k});
	}
	return @loops;
}

sub get_template_name_to_label_mapping{
	my $self = shift;
	my $form = shift;
	my @fields;
	foreach my $k (keys %{$form->{'fields'}}){
		foreach my $m (@{$form->{'fields'}->{$k}}){
			if($m->{'ht_field'}){ # If ht_field is not specified this is probably filled via a loop
				my %h;
				$h{'label'} = $m->{'as'};
				$h{'name'} = $m->{'ht_field'};
				push(@fields,\%h);
			}
		}
	}
	return @fields;
}

sub get_loop_sqls{
	my $self = shift;
	my $form = shift;
	# TWO variables confusingly both named form?! Hell yes!
	my %form = $self->form_to_variables();

	my $lists = $form->{'lists'};

	# Construct SQL for each of the lists specified in the .form
	my %sqls;
	foreach my $k (keys %{$lists}){
		my $v = $lists->{$k};
		my $sql = 'select ';
		my $op = $self->operator_txt_to_operator($v->{'comparison'});
		my $pattern = $self->operator_txt_to_pattern($v->{'comparison'});

#		my $val = $v->{'default_selected'}; # I believe this was never correct and a result of my confusion.
		my $val = $v->{'wherevalue'};
		if( defined($form{$v->{'value_from_html_field'}}) ){
			$val = $form{$v->{'value_from_html_field'}};
		}
		$val =  $self->param('hddb')->quote($val);
		$pattern =~ s/\*/$val/;
		my $where = '';
		if($v->{'where'}){
			$where = "where $v->{'table'}.$v->{'where'} $op $pattern";
		}

		$sql = "select $v->{'fields'} from $v->{'table'} $where order by $v->{'sort'};";
		$sqls{$k} = $sql;
	}

#	# Run each block of SQL and associate results into the HTML::Template via the .form info
#	foreach my $loopname (keys %sqls){
#		$self->insert_loop_into_template($form,$sqls{$loopname},$loopname,undef);
#	}
	return %sqls;
}

# Form Object, SQL query to run, Loop Name to populate, List entry to select.
sub insert_loop_into_template{
	my $self = shift;
	my $form = shift;
	my $sql = shift;
	my $loopname = shift;
	my $match = shift;

	my $thisloop = $form->{'lists'}->{$loopname};

	my $sth = $self->param('hddb')->prepare($sql);
      	$sth->execute();
	my @entries;

	my $selectval = $match;
	$selectval = $thisloop->{'default_selected'} if !defined $selectval;

        while(my $hrrow = $sth->fetchrow_hashref()){
		my %row;

		my @loop_vars = $self->param('template')->query(loop => $loopname);
		foreach my $lv (@loop_vars){
			# If this is the field we select with...
			if($lv eq $thisloop->{'select_with'}){
				$row{$thisloop->{'select_with'}} = '';
				if($hrrow->{$lv} eq $selectval){ 
					$row{$thisloop->{'select_with'}} = ' selected';
				}
			} else{
				# Everything else, pass right through
				$row{$lv} = $hrrow->{$lv};
			}
		}
		push(@entries,\%row);
	}
	if($self->param('template')->query(name => $loopname)){
		$self->param('template')->param($loopname => [@entries]);
	} else{
		$self->throw_error("Loop variable $loopname not found in template.");
	}
}


sub remove_dups{
	my $self = shift;
	my @in = @_;
	my %saw;
	undef %saw;
        @saw{@in} = ();
        my @out = sort keys %saw;  # remove sort if undesired
	return @out;
}

sub form_fill{
	my $self = shift;
	my %form = @_;

	foreach my $k (keys %form){
		if($self->param('template')->query(name => $k)){
			$self->param('template')->param($k => $form{$k})
		} else{
			$self->throw_error("Form field $k has no matching template field!");
		}
	}
}

sub throw_error{
	my $self = shift;
	my $err = shift;

	$err .= '<TMPL_VAR NAME="catch_errors">';
	if($self->param('template')->query(name => 'catch_errors')){
		$self->param('template')->param('catch_errors' => $err);
	}
}

sub highlight_on_error{
	my $self = shift;

	my @errs = @_;

#	my @vars = grep { /^error_/ } $self->param('template')->query;

	foreach my $e (@errs){
		if($self->param('template')->query(name => 'error_'.$e->{'name'})){
			$self->param('template')->param('error_'.$e->{'name'} => ' class="highlightonerror" ');
		}
	}
}

sub check_requirements{
	my $self = shift;
	my $reqmap = shift;
	my @errors;
	my %form = @_;
	my %stipulations = $self->load_requirements($reqmap);

	foreach my $s (keys %stipulations){
		if($stipulations{$s} =~ /required/){
			if(!defined($form{$s}) || $form{$s} eq ''){ #
				my %tmp;
				$tmp{'name'} = $s;
				$tmp{'msg'} = "must not be empty";
				unshift(@errors,\%tmp); # And make 'em appear in the original order
			}
		}
		if($stipulations{$s} =~ /onlynumeric/){
			if($form{$s} !~ /\d+/ and $form{$s} ne ''){
				my %tmp;
				$tmp{'name'} = $s;
				$tmp{'msg'} = "must be a number";
				unshift(@errors,\%tmp);
			}
		}
		if($stipulations{$s} =~ /alphabetic/){
			if($form{$s} !~ /(\w|\s)+/ and $form{$s} ne ''){
				my %tmp;
				$tmp{'name'} = $s;
				$tmp{'msg'} = "must consist of letters only";
				unshift(@errors,\%tmp);
			}
		}
		if($stipulations{$s} =~ /alphanumeric/){
			if($form{$s} !~ /(\w|\d|\s)+/ and $form{$s} ne ''){
				my %tmp;
				$tmp{'name'} = $s;
				$tmp{'msg'} = "must contain no punctuation";
				unshift(@errors,\%tmp);
			}
		}
		if($stipulations{$s} =~ /morethantwo/){
			if(length($form{$s}) < 3){
				my %tmp;
				$tmp{'name'} = $s;
				$tmp{'msg'} = "must be more than two characters";
				unshift(@errors,\%tmp);
			}
		}
		if($stipulations{$s} =~ /morethan(\d+)/){
			my $n = $1;
			if(length($form{$s}) <= $n){
				my %tmp;
				$tmp{'name'} = $s;
				$tmp{'msg'} = "must be more than $n character".($n==1?'':'s');
				unshift(@errors,\%tmp);
			}
		}
		if($stipulations{$s} =~ /isemail/){
			if($form{$s} !~ /.*\@.*\..{2,5}/ and $form{$s} ne ''){
				my %tmp;
				$tmp{'name'} = $s;
				$tmp{'msg'} = "is not a valid email address";
				unshift(@errors,\%tmp);
			}
		}


	}
	return @errors;
}


sub load_requirements{
	my $self = shift;
	my $file = shift;
	my $r = YAML::LoadFile($file);

#	die Data::Dumper::Dumper $r;
	return %{$r};
}

#---------------new stuff----------------#

sub form_to_sql{
	my $self = shift;
	my $match = shift;
	my $form = shift;

	my $sql = 'select ';

	# call _join_to_sql and _fields_to_sql to generate correct sql ...
	my $joins = $self->form_join_to_sql($form->{'join'});
	my $fields = $self->form_fields_to_sql($form->{'fields'});
	my $tables = $self->form_tables_to_sql($form->{'tables'});
	my $where = $self->form_where_to_sql($form->{'where'}->{$form->{'primarytable'}});
	# Do this in two steps so perl doesn't get confused.
	my $v = $self->param('hddb')->quote($match);
	$where =~ s/\*/$v/;

	# In reality sort doesn't matter because everything assumes only one matching record.
	my $sort = $self->form_order_to_sql($form->{'sort'});

	# generate other necessary sql
	
	$sql .= $fields.' from '.$tables.' '.$joins.' where '.$where.' order by '.$sort.';';
#die $sql;
	return $sql;
}

sub form_order_to_sql{
	my $self = shift;
	my $sobj = shift;
	my @sort;
	foreach my $field (@{$sobj}){
		push(@sort,$field);
	}
	return join(', ',@sort);
}


sub form_where_to_sql{
	my $self = shift;
	my $wobj = shift;

	# select... where
	# table.field
	my $sql = $wobj->{'table'}.'.'.$wobj->{'db_field'}.
	# =
	' '.$self->operator_txt_to_operator($wobj->{'comparison'}).
	# value
	' '.$self->operator_txt_to_pattern($wobj->{'comparison'});

	return $sql;
}

sub form_tables_to_sql{
	my $self = shift;
	my $tobj = shift;

	my @tables;
	foreach my $t (@{$tobj}){
		push(@tables,$t);
	}

	return join(', ',@tables);
}

sub operator_extract{
	my $self = shift;
	my $from = shift;
	my $to = shift;
	my $wanted_op = shift;
	my $ops = YAML::LoadFile('maps/generic.cmps'); # replace this with config ref later

	my @ops = @{$ops->{'comparisons'}};

	my $op = ' "INVALID OPERATOR '.$wanted_op.'"';
	foreach my $o (@ops){
		my ($key) = (keys %{$o});
		if($o->{$key}->{$from} eq $wanted_op){
			$op = $o->{$key}->{$to};
			last;
		}
	}
	return $op;
}

sub operator_txt_to_pattern{
	my $self = shift;
	my $pat = shift;
	return $self->operator_extract('txt','pattern',$pat);
}
sub operator_txt_to_operator{
	my $self = shift;
	my $txt_op = shift;
	return $self->operator_extract('txt','sql',$txt_op);
}
sub operator_sql_to_txt{
	my $self = shift;
	my $wanted = shift;
	return $self->operator_extract('sql','txt',$wanted);
}
sub operator_sql_to_pattern{
	my $self = shift;
	my $wanted = shift;
	return $self->operator_extract('sql','pattern',$wanted);
}


sub form_fields_to_sql{
	my $self = shift;
	my $fobj = shift;
	# work on fields object to extract correct SQL ...
	my (@fields,@tables);
	foreach my $table (keys %{$fobj}){
#die Data::Dumper::Dumper $fobj;
		foreach my $field (@{$fobj->{$table}}){
#			if($field->{'ht_field'}){
				my $sql = $field->{'db_field'}.' as '.$self->param('hddb')->quote($field->{'as'});
				push(@fields,$sql);
#			}
		}
		push(@tables,$table);
	}

# We don't want to get the tables from here. Some of these must be listed as joins.
#	$sql = join(', ',@fields).' from '.join(', ',@tables);
	return join(', ',@fields)
}

sub form_join_to_sql{
	my $self = shift;
	my $joinobj = shift;
	my $sql = '';
	# work on join object to extract correct SQL ... 
	my @joins;
	foreach my $join (@{$joinobj}){
		my $operator = $self->operator_txt_to_operator($join->{'on'}->{'comparison'});
		my $sql = $join->{'type'}.' join '.$join->{'table'}.' on ('.$join->{'on'}->{'source'}.' '.$operator.' '.$join->{'on'}->{'dest'}.')';
		push(@joins,$sql);
	}
	return join(' ',@joins);
}


1;
